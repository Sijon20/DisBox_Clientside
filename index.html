<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Previous head content remains the same -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Disbox Client</title>

    <!-- Vue.js Production Build -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <!-- Tailwind CSS (TODO: Replace with local build) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Warning: cdn.tailwindcss.com should not be used in production. -->
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              "disbox-blue": "#5865F2",
              "disbox-green": "#3BA55D",
              "disbox-red": "#ED4245",
              "disbox-yellow": "#FEE75C",
              "discord-gray": {
                50: "#F9FAFB",
                100: "#F3F4F6",
                200: "#E5E7EB",
                300: "#D1D5DB",
                400: "#9CA3AF",
                500: "#6B7280",
                600: "#4B5563",
                700: "#374151",
                800: "#2D3748",
                900: "#1F2937",
              },
            },
            fontFamily: {
              sans: ["Whitney", "sans-serif"],
            },
          },
        },
      };
    </script>

    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />

    <!-- Prevent FOUC by setting theme early -->
    <script>
      document.documentElement.classList.toggle(
        "dark",
        localStorage.theme === "dark" ||
          (!("theme" in localStorage) &&
            window.matchMedia("(prefers-color-scheme: dark)").matches)
      );
    </script>

    <!-- Custom Styling -->
    <style>
      /* Style for the context menu - Refined styling */
      .context-menu {
        position: absolute;
        background-color: white;
        dark-background-color: #2d3748;
        border: 1px solid #e5e7eb;
        dark-border-color: #4a5568;
        border-radius: 0.5rem;
        padding: 0.5rem 0;
        box-shadow: 0 3px 7px rgba(0, 0, 0, 0.15);
        z-index: 50;
      }

      .context-menu-item {
        padding: 0.625rem 1.25rem;
        cursor: pointer;
        color: #4b5563;
        dark-color: #d1d5db;
        white-space: nowrap;
        @apply flex items-center;
      }

      .context-menu-item:hover {
        background-color: #f9fafb;
        dark-background-color: #4a5568;
      }
    </style>
  </head>
  <body class="bg-gray-100 dark:bg-gray-900" @click="closeContextMenu">
    <div id="app">
      <!-- Navigation - Mobile Friendly -->
      <nav class="bg-white dark:bg-discord-gray-800 shadow-md">
        <div class="container mx-auto px-6 py-4 sm:py-3">
          <div class="flex justify-between items-center">
            <div class="text-xl font-semibold text-gray-800 dark:text-white">
              Disbox
            </div>
            <div class="flex items-center space-x-4 sm:space-x-6">
              <div class=" flex space-x-3">
                <button @click="exportBackup" class="bg-disbox-blue text-white py-2 px-4 rounded-md">Export Backup</button>
                <input type="file" ref="importBackupFile" id="importBackupFile" @change="importBackup" class="hidden" />
                <button @click="$refs.importBackupFile.click()" class="bg-disbox-green text-white py-2 px-4 rounded-md">Import Backup</button>
              </div>
              <button
                @click="toggleTheme"
                class="text-gray-800 dark:text-gray-200 hover:text-disbox-blue dark:hover:text-disbox-blue transition-colors duration-200"
              >
                <i class="fas" :class="isDark ? 'fa-sun' : 'fa-moon'"></i>
              </button>
              <a
                href="https://github.com/DisboxApp/web"
                target="_blank"
                class="text-gray-800 dark:text-gray-200 hover:text-disbox-blue dark:hover:text-disbox-blue transition-colors duration-200"
              >
                <i class="fab fa-github text-xl"></i>
              </a>
            </div>
           
            
          </div>
        </div>
      </nav>

      <!-- Main Content -->
      <div class="container mx-auto px-6 py-8">
        <!-- Setup/Welcome Screen - Mobile Friendly -->
        <div v-if="!isSetup" class="max-w-lg sm:max-w-2xl mx-auto">
          <!-- Setup content -->
          <h1
            class="text-3xl sm:text-4xl font-bold text-center mb-6 sm:mb-8 text-gray-800 dark:text-white"
          >
            Welcome to Disbox
          </h1>
          <div
            class="bg-white dark:bg-discord-gray-800 rounded-lg shadow p-6 sm:p-8"
          >
            <h2
              class="text-xl sm:text-2xl font-semibold mb-4 sm:mb-6 text-gray-800 dark:text-white"
            >
              Setup
            </h2>
            <p class="mb-4 sm:mb-6 text-gray-600 dark:text-gray-300">
              Enter your Discord webhook URL to start using Disbox:
            </p>
            <input
              v-model="webhookUrl"
              type="password"
              placeholder="Discord Webhook URL"
              class="w-full p-3 mb-4 sm:mb-6 border rounded focus:ring-2 focus:ring-disbox-blue focus:border-disbox-blue dark:bg-discord-gray-700 dark:border-discord-gray-600 dark:text-gray-100"
            />
            <button
              @click="setupWebhook"
              class="w-full bg-disbox-blue text-white py-3 px-6 rounded-md hover:bg-disbox-blue-600 focus:outline-none focus:ring-2 focus:ring-disbox-blue focus:ring-opacity-50 transition-colors duration-200"
            >
              Get Started
            </button>
          </div>
        </div>

        <!-- File Manager - Mobile Friendly -->
        <div v-else>
          <!-- File Upload & Create Folder Buttons - Modernized -->
          <div
            class="mb-4 sm:mb-6 flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3"
          >
            <input
              type="file"
              ref="fileInput"
              @change="handleFileUpload"
              class="hidden"
            />
            <button
              @click="$refs.fileInput.click()"
              class="w-full sm:w-auto bg-disbox-blue text-white py-3 px-6 rounded-md hover:bg-disbox-blue-600 focus:outline-none focus:ring-2 focus:ring-disbox-blue focus:ring-opacity-50 transition-colors duration-200"
            >
              <i class="fas fa-upload mr-2"></i> Upload File
            </button>
            <button
              @click="createFolder"
              class="w-full sm:w-auto bg-disbox-green text-white py-3 px-6 rounded-md hover:bg-disbox-green-600 focus:outline-none focus:ring-2 focus:ring-disbox-green focus:ring-opacity-50 transition-colors duration-200"
            >
              <i class="fas fa-folder-plus mr-2"></i> New Folder
            </button>
          </div>

          <!-- Path Navigation - Breadcrumbs Style - Mobile Friendly -->
          <div
            class="flex items-center mb-4 sm:mb-6 space-x-2 text-gray-600 dark:text-gray-300 overflow-x-auto"
          >
            <template v-for="(part, index) in currentPath" :key="index">
              <span v-if="index > 0">
                <i
                  class="fas fa-chevron-right mx-1 text-gray-400 dark:text-gray-500"
                ></i>
              </span>
              <span
                class="cursor-pointer hover:text-disbox-blue dark:hover:text-disbox-blue transition-colors duration-200 whitespace-nowrap"
                @click="navigateTo(index)"
              >
                {{ part || 'Root' }}
              </span>
            </template>
          </div>

          <!-- File List - Modern Table Style - Mobile Friendly -->
          <div
            class="bg-white dark:bg-discord-gray-800 rounded-lg shadow overflow-hidden"
          >
            <div class="overflow-x-auto">
              <table
                class="min-w-full table-auto divide-y divide-gray-200 dark:divide-discord-gray-700"
              >
                <!-- table-auto for responsive columns -->
                <thead class="bg-gray-50 dark:bg-discord-gray-700">
                  <tr>
                    <th
                      class="px-6 py-3 text-left text-xs sm:text-sm font-semibold text-gray-500 dark:text-gray-300 uppercase tracking-wider"
                    >
                      Name
                    </th>
                    <th
                      class="hidden sm:table-cell px-6 py-3 text-left text-xs sm:text-sm font-semibold text-gray-500 dark:text-gray-300 uppercase tracking-wider"
                    >
                      Size
                    </th>
                    <th
                      class="hidden sm:table-cell px-6 py-3 text-left text-xs sm:text-sm font-semibold text-gray-500 dark:text-gray-300 uppercase tracking-wider"
                    >
                      Modified
                    </th>
                    <th
                      class="px-6 py-3 text-right text-xs font-semibold text-gray-500 dark:text-gray-300 uppercase tracking-wider"
                    >
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody
                  class="bg-white dark:bg-discord-gray-800 divide-y divide-gray-200 dark:divide-discord-gray-700"
                >
                  <tr
                    v-for="file in currentFiles"
                    :key="file.id"
                    class="hover:bg-gray-100 dark:hover:bg-discord-gray-700 transition-colors duration-150"
                  >
                    <td class="px-6 py-4 whitespace-nowrap text-xs sm:text-sm">
                      <div class="flex items-center">
                        <i
                          :class="getFileIcon(file)"
                          class="mr-3 text-gray-600 dark:text-gray-400"
                        ></i>
                        <span
                          class="text-gray-900 dark:text-gray-100 cursor-pointer hover:text-disbox-blue dark:hover:text-disbox-blue transition-colors duration-200"
                          @click="file.type === 'directory' ? navigateToFolder(file) : null"
                          >{{ truncatedFileName(file.name) }}</span
                        >
                        <!-- Using truncatedFileName method -->
                      </div>
                    </td>
                    <td
                      class="hidden sm:table-cell px-6 py-4 whitespace-nowrap text-xs sm:text-sm text-gray-500 dark:text-gray-300"
                    >
                      {{ formatSize(file.size) }}
                    </td>
                    <td
                      class="hidden sm:table-cell px-6 py-4 whitespace-nowrap text-xs sm:text-sm text-gray-500 dark:text-gray-300"
                    >
                      {{ formatDate(file.updated_at) }}
                    </td>
                    <td
                      class="px-6 py-4 whitespace-nowrap text-right font-medium space-x-3"
                    >
                      <div class="flex justify-end space-x-2">
                        <button
                          @click="downloadFile(file)"
                          v-if="file.type !== 'directory'"
                          class="text-disbox-blue hover:text-disbox-blue-600 dark:text-disbox-blue-400 dark:hover:text-disbox-blue-300 transition-colors duration-200"
                        >
                          <i class="fas fa-download"></i>
                        </button>
                        <button
                          @click="shareFile(file)"
                          v-if="file.type !== 'directory'"
                          class="text-disbox-green hover:text-disbox-green-600 dark:text-disbox-green-400 dark:hover:text-disbox-green-300 transition-colors duration-200"
                        >
                          <i class="fas fa-share-alt"></i>
                        </button>
                        <button
                          @click="initiateMove(file)"
                          class="text-disbox-yellow hover:text-disbox-yellow-600 dark:text-disbox-yellow-400 dark:hover:text-disbox-yellow-300 transition-colors duration-200"
                        >
                          <i class="fas fa-arrows-alt"></i>
                        </button>
                        <button
                          @click="deleteFile(file)"
                          class="text-disbox-red hover:text-disbox-red-600 dark:text-disbox-red-400 dark:hover:text-disbox-red-300 transition-colors duration-200"
                        >
                          <i class="fas fa-trash"></i>
                        </button>
                        <button
                          @click="renameFile(file)"
                          class="text-purple-600 hover:text-purple-700 dark:text-purple-400 dark:hover:text-purple-300 transition-colors duration-200"
                        >
                          <i class="fas fa-edit"></i>
                        </button>
                      </div>
                    </td>
                  </tr>
                  <tr v-if="currentFiles.length === 0">
                    <td
                      colspan="4"
                      class="px-6 py-4 whitespace-nowrap text-center text-gray-500 dark:text-gray-300"
                    >
                      This folder is empty.
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <!-- Context Menu - Modernized Styling (No changes needed for responsiveness in this part) -->
          <div
            v-if="showContextMenu"
            class="context-menu"
            :style="{ left: contextMenuX + 'px', top: contextMenuY + 'px' }"
          >
            <div
              class="context-menu-item"
              @click="downloadFile(contextMenuFile); closeContextMenu()"
              v-if="contextMenuFile && contextMenuFile.type !== 'directory'"
            >
              <i class="fas fa-download mr-3"></i> Download
            </div>
            <div
              class="context-menu-item"
              @click="navigateToFolder(contextMenuFile); closeContextMenu()"
              v-if="contextMenuFile && contextMenuFile.type === 'directory'"
            >
              <i class="fas fa-folder-open mr-3"></i> Open
            </div>
            <div
              class="context-menu-item"
              @click="initiateMove(contextMenuFile); closeContextMenu()"
            >
              <i class="fas fa-arrows-alt mr-3"></i> Move
            </div>
            <div
              class="context-menu-item"
              @click="renameFile(contextMenuFile); closeContextMenu()"
            >
              <i class="fas fa-edit mr-3"></i> Rename
            </div>
            <div
              class="context-menu-item text-disbox-red dark:text-disbox-red-400"
              @click="deleteFile(contextMenuFile); closeContextMenu()"
            >
              <i class="fas fa-trash mr-3"></i> Delete
            </div>
            <div
              class="context-menu-item"
              @click="shareFile(contextMenuFile); closeContextMenu()"
              v-if="contextMenuFile && contextMenuFile.type !== 'directory'"
            >
              <i class="fas fa-share-alt mr-3"></i> Share (Soon)
            </div>
          </div>
        </div>
      </div>

      <!-- Progress Modal - Refined Styling (No changes needed for responsiveness in this part) -->
      <div
        v-if="showProgress"
        class="fixed bottom-6 right-6 bg-white dark:bg-discord-gray-800 p-6 rounded-lg shadow-lg"
      >
        <p class="text-gray-900 dark:text-gray-100 mb-3 font-medium">
          {{ progressMessage }}
        </p>
        <div
          class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-discord-gray-700"
        >
          <div
            class="bg-disbox-blue h-2.5 rounded-full"
            :style="{ width: progress + '%' }"
          ></div>
        </div>
      </div>

      <!-- Move Modal - Modernized Styling - Mobile Friendly -->
      <div
        v-if="showMoveModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      >
        <div
          class="bg-white dark:bg-discord-gray-800 p-6 sm:p-8 rounded-lg shadow-xl max-w-md sm:max-w-lg w-full"
        >
          <h3
            class="text-xl font-bold mb-4 sm:mb-6 text-gray-800 dark:text-white"
          >
            Move {{ selectedItem ? selectedItem.name : '' }}
          </h3>
          <div class="mb-4 sm:mb-6">
            <p class="text-gray-600 dark:text-gray-300 mb-2 sm:mb-3">
              Select destination folder:
            </p>
            <div
              class="max-h-48 sm:max-h-60 overflow-y-auto border dark:border-discord-gray-600 rounded-md"
            >
              <div
                class="p-2 sm:p-3 hover:bg-gray-100 dark:hover:bg-discord-gray-700 cursor-pointer flex items-center"
                @click="selectDestination('')"
              >
                <i class="fas fa-folder mr-3"></i> Root
              </div>
              <div
                v-for="folder in availableFolders"
                :key="folder.path"
                class="p-2 sm:p-3 hover:bg-gray-100 dark:hover:bg-discord-gray-700 cursor-pointer flex items-center"
                @click="selectDestination(folder.path)"
              >
                <i class="fas fa-folder mr-3"></i> {{ folder.path }}
              </div>
            </div>
          </div>
          <div
            class="flex flex-col sm:flex-row justify-end space-y-2 sm:space-y-0 sm:space-x-3"
          >
            <button
              @click="showMoveModal = false"
              class="w-full sm:w-auto bg-gray-300 text-gray-700 py-3 px-6 rounded-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-opacity-50 transition-colors duration-200 dark:bg-discord-gray-600 dark:text-gray-200 dark:hover:bg-discord-gray-500 dark:focus:ring-discord-gray-500"
            >
              Cancel
            </button>
            <button
              @click="confirmMove"
              class="w-full sm:w-auto bg-disbox-blue text-white py-3 px-6 rounded-md hover:bg-disbox-blue-600 focus:outline-none focus:ring-2 focus:ring-disbox-blue focus:ring-opacity-50 transition-colors duration-200"
            >
              Move
            </button>
          </div>
        </div>
      </div>

      <!-- Download Link Modal - Modernized Styling - Mobile Friendly -->
      <div
        v-if="showDownloadModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
      >
        <!-- Download modal content -->
        <div
          class="bg-white dark:bg-discord-gray-800 p-6 sm:p-8 rounded-lg shadow-xl max-w-md sm:max-w-lg w-full"
        >
          <h3
            class="text-xl font-bold mb-4 sm:mb-6 text-gray-800 dark:text-white"
          >
            Download File
          </h3>
          <p class="mb-4 sm:mb-6 text-gray-600 dark:text-gray-300">
            Automatic download failed due to browser restrictions. Please use
            one of these options:
          </p>
          <div v-if="downloadLinks.length > 0" class="mb-4 sm:mb-6">
            <p
              class="mb-2 sm:mb-3 text-gray-600 dark:text-gray-300 font-medium"
            >
              Download File Parts:
            </p>
            <div class="space-y-2 sm:space-y-3">
              <div
                v-for="(link, index) in downloadLinks"
                :key="index"
                class="flex flex-col sm:flex-row items-start sm:items-center justify-between"
              >
                <a
                  :href="link"
                  target="_blank"
                  class="text-disbox-blue hover:text-disbox-blue-700 dark:text-disbox-blue-400 dark:hover:text-disbox-blue-300 transition-colors duration-200 break-all"
                >
                  Part {{index + 1}} of {{downloadLinks.length}}
                </a>
                <button
                  @click="copyToClipboard(link)"
                  class="mt-2 sm:mt-0 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 transition-colors duration-200"
                >
                  <i class="fas fa-copy"></i>
                </button>
              </div>
            </div>
            <p class="mt-2 sm:mt-3 text-sm text-gray-500 dark:text-gray-400">
              Note: You'll need to combine these files after downloading.
            </p>
          </div>
          <div class="flex justify-end space-x-3 mt-6 sm:mt-8">
            <button
              @click="showDownloadModal = false"
              class="w-full sm:w-auto bg-gray-300 text-gray-700 py-3 px-6 rounded-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-opacity-50 transition-colors duration-200 dark:bg-discord-gray-600 dark:text-gray-200 dark:hover:bg-discord-gray-500 dark:focus:ring-discord-gray-500"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Constants
      const FILE_CHUNK_SIZE = 8 * 1024 * 1024; // 8MB chunks

      // Helper functions
      async function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      async function* readFileChunks(file, chunkSize) {
        let offset = 0;
        let chunkIndex = 0;
        const totalChunks = Math.ceil(file.size / chunkSize);

        while (offset < file.size) {
          const chunk = file.slice(offset, offset + chunkSize);
          yield chunk;
          offset += chunkSize;
          chunkIndex++;
        }
      }

      // Discord webhook client class
      class DiscordWebhookClient {
        constructor(webhookUrl) {
          const urlParts = webhookUrl.split("/");
          const id = urlParts[urlParts.length - 2];
          const token = urlParts[urlParts.length - 1];
          this.baseUrl = `https://discord.com/api/webhooks/${id}/${token}`;
          this.rateLimitWaits = {};
        }

        async fetchFromApi(path, { type, method, body }) {
          if (this.rateLimitWaits[type] > 0) {
            await sleep(this.rateLimitWaits[type]);
          }

          const response = await fetch(`${this.baseUrl}${path}`, {
            method: method,
            body: body,
          });

          const headers = response.headers;
          const remainingRequests = Number(
            headers.get("X-RateLimit-Remaining")
          );
          const resetAfter = Number(headers.get("X-RateLimit-Reset-After"));
          this.rateLimitWaits[type] =
            remainingRequests === 0 ? resetAfter * 1000 : 0;

          const status = response.status;
          if (status === 429) {
            const responseJson = await response.json();
            this.rateLimitWaits[type] = responseJson.retry_after * 1000;
            return await this.fetchFromApi(path, { method, body, type });
          }

          if (status >= 400) {
            throw new Error(
              `Failed to ${type} with status ${status}: ${await response.text()}`
            );
          }

          return response;
        }

        async sendAttachment(filename, blob) {
          const formData = new FormData();
          formData.append("payload_json", JSON.stringify({}));
          formData.append("file", blob, filename);

          const response = await this.fetchFromApi("?wait=true", {
            type: "sendAttachment",
            method: "POST",
            body: formData,
          });

          return await response.json();
        }

        async getMessage(id) {
          const response = await this.fetchFromApi(`/messages/${id}`, {
            type: "getMessage",
            method: "GET",
          });
          return await response.json();
        }

        async deleteMessage(id) {
          await this.fetchFromApi(`/messages/${id}`, {
            type: "deleteMessage",
            method: "DELETE",
          });
        }
      }

      // Discord storage class
      class DiscordStorage {
        constructor(webhookUrl) {
          this.webhookClient = new DiscordWebhookClient(webhookUrl);
        }

        async downloadFile(messageIds, onProgress, fileSize) {
          const chunks = [];
          let downloadedBytes = 0;

          for (let id of messageIds) {
            const message = await this.webhookClient.getMessage(id);
            const url = message.attachments[0].url;
            const proxyUrl = `https://api.allorigins.win/raw?url=${
              (encodeURIComponent(url),
              {
                headers: {
                  Origin: "https://disboxapp.github.io", // Keep this
                  Referer: "https://disboxapp.github.io/", // Add this explicitly
                },
              })
            }`;
            const response = await fetch(proxyUrl);

            if (!response.ok) {
              throw new Error("Failed to download chunk");
            }

            const blob = await response.blob();
            chunks.push(blob);

            downloadedBytes += blob.size;
            if (onProgress) {
              onProgress(downloadedBytes, fileSize);
            }
          }

          return new Blob(chunks);
        }

        async getAttachmentUrls(messageIds) {
          const attachmentUrls = [];
          for (let id of messageIds) {
            try {
              const message = await this.webhookClient.getMessage(id);
              attachmentUrls.push(message.attachments[0].url);
            } catch (error) {
              attachmentUrls.push(null);
            }
          }
          return attachmentUrls;
        }

        async upload(sourceFile, namePrefix, onProgress = null) {
          const messageIds = [];
          let uploadedBytes = 0;
          let index = 0;

          try {
            const totalChunks = Math.ceil(sourceFile.size / FILE_CHUNK_SIZE);

            for await (const chunk of readFileChunks(
              sourceFile,
              FILE_CHUNK_SIZE
            )) {
              const result = await this.webhookClient.sendAttachment(
                `${sourceFile.size}_${index}`,
                chunk
              );

              messageIds.push(result.id);
              uploadedBytes += chunk.size;
              index++;

              if (onProgress) {
                onProgress(uploadedBytes, sourceFile.size);
              }
            }

            return messageIds;
          } catch (error) {
            throw error;
          }
        }

        async delete(messageIds, onProgress = null) {
          let deletedCount = 0;
          if (onProgress) {
            onProgress(0, messageIds.length);
          }

          for (let id of messageIds) {
            await this.webhookClient.deleteMessage(id);
            deletedCount++;
            if (onProgress) {
              onProgress(deletedCount, messageIds.length);
            }
          }
        }
      }

      // Initialize Vue app
      const { createApp } = Vue;

      createApp({
        data() {
          return {
            isSetup: false,
            webhookUrl: "",
            isDark:
              localStorage.theme === "dark" ||
              (!("theme" in localStorage) &&
                window.matchMedia("(prefers-color-scheme: dark)").matches),
            currentPath: [""],
            currentFiles: [],
            showProgress: false,
            progressMessage: "",
            progress: 0,
            db: null,
            discordStorage: null,
            showDownloadModal: false,
            showMoveModal: false,
            downloadLinks: [],
            activeFile: null,
            selectedItem: null,
            availableFolders: [],
            selectedDestination: null,
            maxFileNameLengthMobile: 20, // Maximum length of filenames on mobile devices

            showContextMenu: false,
            contextMenuX: 0,
            contextMenuY: 0,
            contextMenuFile: null,
          };
        },
        computed: {
          // Computed property for truncated filename
          truncatedFileName() {
            return (filename) => {
              if (!filename) return "";
              if (
                window.innerWidth <= 640 &&
                filename.length > this.maxFileNameLengthMobile
              ) {
                // Check for mobile screen width (sm: breakpoint is 640px)
                const startLength = Math.ceil(this.maxFileNameLengthMobile / 2);
                const endLength = Math.floor(this.maxFileNameLengthMobile / 2);
                const start = filename.substring(0, startLength);
                const end = filename.substring(filename.length - endLength);
                return `${start}...${end}`;
              }
              return filename; // Return original filename if not mobile or not exceeding length
            };
          },
        },

        async mounted() {
          document.documentElement.classList.toggle("dark", this.isDark);

          const request = indexedDB.open("DisboxDB", 1);

          request.onerror = (event) => {
            console.error("IndexedDB error:", event.target.error);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains("files")) {
              const fileStore = db.createObjectStore("files", {
                keyPath: "path",
              });
              fileStore.createIndex("parentPath", "parentPath", {
                unique: false,
              });
            }
            if (!db.objectStoreNames.contains("settings")) {
              db.createObjectStore("settings");
            }
          };

          request.onsuccess = async (event) => {
            this.db = event.target.result;
            const settings = await this.getFromStore("settings", "webhookUrl");
            if (settings) {
              this.webhookUrl = settings;
              this.discordStorage = new DiscordStorage(settings);
              this.isSetup = true;
              this.loadCurrentDirectory();
            }
          };

          window
            .matchMedia("(prefers-color-scheme: dark)")
            .addEventListener("change", this.handleSystemThemeChange);
        },

        methods: {
          async exportBackup() {
            const transaction = this.db.transaction("files", "readonly");
            const store = transaction.objectStore("files");
            const request = store.getAll();

            request.onsuccess = () => {
              const data = JSON.stringify(request.result, null, 2);
              const blob = new Blob([data], { type: "application/json" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "backup.json";
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            };
          },

          async importBackup(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const data = JSON.parse(e.target.result);
                const transaction = this.db.transaction("files", "readwrite");
                const store = transaction.objectStore("files");

                for (const item of data) {
                  store.put(item);
                }

                this.loadCurrentDirectory();
                alert("Backup successfully imported!");
              } catch (error) {
                alert("Invalid backup file.");
              }
            };
            reader.readAsText(file);
          },

          async getFromStore(storeName, key) {
            return new Promise((resolve, reject) => {
              const transaction = this.db.transaction(storeName, "readonly");
              const store = transaction.objectStore(storeName);
              const request = store.get(key);
              request.onerror = () => reject(request.error);
              request.onsuccess = () => resolve(request.result);
            });
          },

          async putInStore(storeName, key, value) {
            return new Promise((resolve, reject) => {
              const transaction = this.db.transaction(storeName, "readwrite");
              const store = transaction.objectStore(storeName);
              const request = key ? store.put(value, key) : store.put(value);
              request.onerror = () => reject(request.error);
              request.onsuccess = () => resolve(request.result);
            });
          },

          async setupWebhook() {
            if (!this.webhookUrl) return;
            try {
              await this.putInStore("settings", "webhookUrl", this.webhookUrl);
              this.discordStorage = new DiscordStorage(this.webhookUrl);
              this.isSetup = true;
              this.loadCurrentDirectory();
            } catch (error) {
              console.error("Failed to save webhook URL:", error);
              alert("Failed to save webhook URL");
            }
          },

          toggleTheme() {
            this.isDark = !this.isDark;
            document.documentElement.classList.toggle("dark", this.isDark);
            localStorage.theme = this.isDark ? "dark" : "light";
          },

          handleSystemThemeChange(e) {
            if (!("theme" in localStorage)) {
              this.isDark = e.matches;
              document.documentElement.classList.toggle("dark", this.isDark);
            }
          },

          async loadCurrentDirectory() {
            // Construct the path for the current directory
            const path = this.currentPath.join("/");
            console.log("Loading directory:", path); // Log the path being loaded

            const transaction = this.db.transaction("files", "readonly");
            const store = transaction.objectStore("files");
            const index = store.index("parentPath");

            const request = index.getAll(path); // Query using the parentPath index

            request.onsuccess = () => {
              this.currentFiles = request.result || [];
              console.log("Files loaded:", this.currentFiles); // Log the loaded files
              if (!this.currentFiles) {
                this.currentFiles = [];
              }
            };
            request.onerror = (event) => {
              console.error("Error loading directory:", event.target.error);
              this.currentFiles = [];
            };
          },

          navigateTo(index) {
            this.currentPath = this.currentPath.slice(0, index + 1);
            this.loadCurrentDirectory();
          },

          navigateToFolder(file) {
            if (file && file.type === "directory") {
              this.currentPath.push(file.name);
              this.loadCurrentDirectory();
            }
          },

          formatSize(bytes) {
            if (!bytes) return "0 B";
            const sizes = ["B", "KB", "MB", "GB"];
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
          },

          formatDate(date) {
            return new Date(date).toLocaleString();
          },

          getFileIcon(file) {
            const iconBase = "fas fa-";
            if (file.type === "directory") return iconBase + "folder";
            const ext = file.name.split(".").pop().toLowerCase();
            const iconMap = {
              pdf: "file-pdf",
              doc: "file-word",
              docx: "file-word",
              xls: "file-excel",
              xlsx: "file-excel",
              ppt: "file-powerpoint",
              pptx: "file-powerpoint",
              jpg: "file-image",
              jpeg: "file-image",
              png: "file-image",
              gif: "file-image",
              mp3: "file-audio",
              wav: "file-audio",
              mp4: "file-video",
              avi: "file-video",
              zip: "file-archive",
              rar: "file-archive",
              txt: "file-alt",
            };
            return iconBase + (iconMap[ext] || "file");
          },

          async handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            this.showProgress = true;
            this.progressMessage = `Uploading ${file.name}`;
            this.progress = 0;

            try {
              const filePath = [...this.currentPath, file.name].join("/");
              const fileMetadata = {
                path: filePath,
                parentPath: this.currentPath.join("/"),
                name: file.name,
                type: "file",
                size: file.size,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString(),
              };

              const updateProgress = (uploaded, total) => {
                const percent = Math.round((uploaded / total) * 100);
                const uploadedMB = (uploaded / (1024 * 1024)).toFixed(2);
                const totalMB = (total / (1024 * 1024)).toFixed(2);
                this.progress = percent;
                this.progressMessage = `Uploading ${file.name} (${uploadedMB}MB / ${totalMB}MB)`;
              };

              const messageIds = await this.discordStorage.upload(
                file,
                filePath,
                updateProgress
              );

              fileMetadata.content = JSON.stringify(messageIds);
              await this.putInStore("files", null, fileMetadata);
              this.loadCurrentDirectory();
            } catch (error) {
              console.error("Upload failed:", error);
              alert("Failed to upload file");
            }

            setTimeout(() => {
              this.showProgress = false;
            }, 2000);

            event.target.value = null;
          },

          async createFolder() {
            const name = prompt("Enter folder name:");
            if (!name) return;

            try {
              const folderPath = [...this.currentPath, name].join("/");
              await this.putInStore("files", null, {
                path: folderPath,
                parentPath: this.currentPath.join("/"),
                name: name,
                type: "directory",
                size: 0,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString(),
              });

              this.loadCurrentDirectory();
            } catch (error) {
              console.error("Failed to create folder:", error);
              alert("Failed to create folder");
            }
          },

          async deleteFile(file) {
            if (!confirm(`Are you sure you want to delete ${file.name}?`))
              return;

            this.showProgress = true;
            this.progressMessage = `Deleting ${file.name}`;
            this.progress = 0;

            try {
              if (file.type === "file" && file.content) {
                const messageIds = JSON.parse(file.content);
                await this.discordStorage.delete(
                  messageIds,
                  (deleted, total) => {
                    this.progress = Math.round((deleted / total) * 100);
                  }
                );
              }

              const transaction = this.db.transaction("files", "readwrite");
              const store = transaction.objectStore("files");
              await store.delete(file.path);
              this.loadCurrentDirectory();
            } catch (error) {
              console.error("Failed to delete:", error);
              alert("Failed to delete");
            }

            setTimeout(() => {
              this.showProgress = false;
            }, 2000);
          },

          async downloadFile(file) {
            const messageIds = JSON.parse(file.content);

            this.showProgress = true;
            this.progressMessage = `Downloading ${file.name}`;
            this.progress = 0;

            try {
              const updateProgress = (downloadedBytes, totalBytes) => {
                const percent = Math.round(
                  (downloadedBytes / totalBytes) * 100
                );
                this.progress = percent;
                this.progressMessage = `Downloading ${file.name} (${percent}%)`;
              };

              const fileBlob = await this.discordStorage.downloadFile(
                messageIds,
                updateProgress,
                file.size
              );

              const downloadUrl = URL.createObjectURL(fileBlob);
              const a = document.createElement("a");
              a.href = downloadUrl;
              a.download = file.name.includes(".")
                ? file.name
                : file.name + ".mp4";
              document.body.appendChild(a);
              a.click();

              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
              }, 100);
            } catch (error) {
              console.error("Failed to download file:", error);
            } finally {
              setTimeout(() => {
                this.showProgress = false;
              }, 2000);
            }
          },

          copyToClipboard(text) {
            navigator.clipboard
              .writeText(text)
              .then(() => alert("Link copied to clipboard"))
              .catch((err) => console.error("Failed to copy link:", err));
          },

          async loadAvailableFolders() {
            const transaction = this.db.transaction("files", "readonly");
            const store = transaction.objectStore("files");
            const index = store.index("parentPath");
            const request = store.getAll();

            return new Promise((resolve, reject) => {
              request.onerror = () => reject(request.error);
              request.onsuccess = () => {
                // Get all folders and their full paths
                const folders = request.result
                  .filter((item) => item.type === "directory")
                  .map((folder) => ({
                    path: folder.path,
                    name: folder.name,
                  }));
                resolve(folders);
              };
            });
          },

          async initiateMove(file) {
            this.selectedItem = file;
            this.availableFolders = await this.loadAvailableFolders();
            this.selectedDestination = null;
            this.showMoveModal = true;
          },

          selectDestination(path) {
            this.selectedDestination = path;
          },

          async confirmMove() {
            if (!this.selectedItem) return;

            const itemToMovePath = this.selectedItem.path;
            const destinationPath = this.selectedDestination;

            // Prevent moving folder into itself or its subfolders
            if (this.selectedItem.type === "directory" && destinationPath) {
              if (
                destinationPath === itemToMovePath ||
                destinationPath.startsWith(itemToMovePath + "/")
              ) {
                alert(
                  "Cannot move a folder into itself or a subdirectory of itself."
                );
                this.showMoveModal = false;
                return; // Exit the function early
              }
            }

            try {
              this.showProgress = true;
              this.progressMessage = `Moving ${this.selectedItem.name}`;
              this.progress = 0;

              const newParentPath = this.selectedDestination;
              const currentItem = await this.getFromStore(
                "files",
                this.selectedItem.path
              );

              if (!currentItem) {
                throw new Error("Item not found");
              }

              // Update item path and parent path
              const newPath = newParentPath
                ? `${newParentPath}/${this.selectedItem.name}`
                : this.selectedItem.name;
              const updatedItem = {
                ...currentItem,
                path: newPath,
                parentPath: newParentPath || "",
                updated_at: new Date().toISOString(),
              };

              // Delete from old location and add to new location
              const transaction = this.db.transaction("files", "readwrite");
              const store = transaction.objectStore("files");
              await store.delete(this.selectedItem.path);
              await this.putInStore("files", null, updatedItem);

              // If it's a folder, update all nested items
              if (this.selectedItem.type === "directory") {
                const allItems = await this.loadAllItems();
                const nestedItems = allItems.filter((item) =>
                  item.path.startsWith(this.selectedItem.path + "/")
                );

                for (const item of nestedItems) {
                  const newNestedPath = item.path.replace(
                    this.selectedItem.path,
                    newPath
                  );
                  const newNestedParentPath = item.parentPath.replace(
                    this.selectedItem.path,
                    newPath
                  );

                  const updatedNestedItem = {
                    ...item,
                    path: newNestedPath,
                    parentPath: newNestedParentPath,
                    updated_at: new Date().toISOString(),
                  };

                  await store.delete(item.path);
                  await this.putInStore("files", null, updatedNestedItem);
                }
              }

              this.showMoveModal = false;
              this.loadCurrentDirectory();
            } catch (error) {
              console.error("Failed to move item:", error);
              alert("Failed to move item");
            } finally {
              this.showProgress = false;
              this.selectedItem = null;
            }
          },

          async loadAllItems() {
            const transaction = this.db.transaction("files", "readonly");
            const store = transaction.objectStore("files");
            return new Promise((resolve, reject) => {
              const request = store.getAll();
              request.onerror = () => reject(request.error);
              request.onsuccess = () => resolve(request.result);
            });
          },

          async shareFile(file) {
            alert("Share functionality coming soon!");
          },

          openContextMenu(event, file) {
            event.preventDefault();
            this.contextMenuX = event.clientX;
            this.contextMenuY = event.clientY;
            this.contextMenuFile = file;
            this.showContextMenu = true;
          },

          closeContextMenu() {
            this.showContextMenu = false;
            this.contextMenuFile = null;
          },

          async renameFile(file) {
            const newName = prompt(`Enter new name for "${file.name}":`);
            if (!newName || newName.trim() === "") return;

            try {
              const currentItem = await this.getFromStore("files", file.path);
              if (!currentItem) {
                throw new Error("File not found for renaming");
              }

              const oldPathParts = file.path.split("/");
              oldPathParts.pop(); // Remove the old name
              const newParentPath = oldPathParts.join("/");
              const newPath = newParentPath
                ? `${newParentPath}/${newName}`
                : newName;

              const updatedItem = {
                ...currentItem,
                name: newName,
                path: newPath,
                updated_at: new Date().toISOString(),
              };

              const transaction = this.db.transaction("files", "readwrite");
              const store = transaction.objectStore("files");
              await store.delete(file.path);
              await this.putInStore("files", null, updatedItem);

              if (file.type === "directory") {
                const allItems = await this.loadAllItems();
                const nestedItems = allItems.filter((item) =>
                  item.path.startsWith(file.path + "/")
                );

                for (const nestedItem of nestedItems) {
                  const newNestedPath = nestedItem.path.replace(
                    file.path,
                    newPath
                  );
                  const newNestedParentPath = nestedItem.parentPath.replace(
                    file.path,
                    newPath
                  );

                  const updatedNestedItem = {
                    ...nestedItem,
                    path: newNestedPath,
                    parentPath: newNestedParentPath,
                    updated_at: new Date().toISOString(),
                  };
                  await store.delete(nestedItem.path);
                  await this.putInStore("files", null, updatedNestedItem);
                }
              }
              this.loadCurrentDirectory();
            } catch (error) {
              console.error("Failed to rename file:", error);
              alert("Failed to rename file");
            }
          },
        },
      }).mount("#app");
    </script>
  </body>
</html>
